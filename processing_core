# ==============================================================================
# Disclaimer
# Copyright (C) 2025 Giampiero Mineo
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see https://www.gnu.org/licenses/gpl-3.0.html
# ==============================================================================

import numpy as np
from scipy.spatial import ConvexHull
import trimesh
import laspy
import os
from typing import Optional, Tuple, List
import random # Used for random sampling

# Import custom data types
from data_structures import (
    HullResult, MorpResult, MAX_VERTICES_FOR_CHORD_CALC
)

# ==============================================================================
# 1. Input File Management
# ==============================================================================

def read_points(file_path: str) -> Optional[np.ndarray]:
    """
    Reads 3D points from a file (.txt, .obj, or .las).

    Args:
        file_path: Path to the input file.

    Returns:
        NumPy array of points (N, 3) or None on error.
    """
    try:
        file_extension = os.path.splitext(file_path)[1].lower()
        if file_extension == '.txt':
            # Assumes first three columns are X, Y, Z
            points = np.loadtxt(file_path, usecols=(0, 1, 2))
        elif file_extension == '.obj':
            mesh = trimesh.load(file_path, process=False)
            if isinstance(mesh, trimesh.Trimesh):
                points = mesh.vertices
            else:
                print(f"Error: OBJ file {os.path.basename(file_path)} is not a valid 3D object.")
                return None
        elif file_extension == '.las':
            las = laspy.read(file_path)
            points = np.vstack((las.x, las.y, las.z)).transpose()
        else:
            print(f"Error: File format '{file_extension}' not supported.")
            return None
            
        if points.ndim != 2 or points.shape[1] != 3:
             print(f"Error: Points array has incorrect shape {points.shape}. Expected (N, 3).")
             return None

        return points
    except Exception as e:
        print(f"Error during file reading {os.path.basename(file_path)}: {e}")
        return None

# ==============================================================================
# 2. Convex Hull Calculation
# ==============================================================================

def calculate_convex_hull(points: np.ndarray) -> Tuple[float, float, Optional[trimesh.Trimesh]]:
    """
    Calculates the Convex Hull volume, surface area, and Trimesh object.

    Args:
        points: NumPy array of points (N, 3).

    Returns:
        Tuple: (Volume, Area, Trimesh Mesh)
    """
    if len(points) < 4:
        return 0.0, 0.0, None
    
    try:
        hull = ConvexHull(points)
       
        # Create a Trimesh object from the hull results
        remapped_faces = np.searchsorted(hull.vertices, hull.simplices)
        mesh = trimesh.Trimesh(
            vertices=points[hull.vertices], 
            faces=remapped_faces, 
            process=True
        )

        # Ensure the mesh is watertight for volume calculation
        if not mesh.is_watertight:
            # Attempt to fill holes; suppresses potential Trimesh warnings/errors if it fails
            try:
                mesh = mesh.fill_holes() 
            except Exception:
                pass # Continue with non-watertight mesh, volume will be 0.0

        mesh.fix_normals()
        
        area = mesh.area
        volume = mesh.volume if mesh.is_watertight else 0.0

        return volume, area, mesh
    
    except Exception as e:
        print(f"Error in Convex Hull calculation: {e}")
        return 0.0, 0.0, None

# ==============================================================================
# 3. Morphometric Indices (Alpha, Beta, Flattening)
# ==============================================================================

def calculate_morp_indices(mesh: Optional[trimesh.Trimesh]) -> Tuple[Optional[float], Optional[float], Optional[float], Optional[float], Optional[float]]:
    """
    Calculates Alpha, Beta, and Flattening indices from the Convex Hull mesh.

    Args:
        mesh: The Convex Hull mesh (Trimesh object).

    Returns:
        Tuple: (Alpha, Beta, Flattening, Volume, Area)
    """
    alpha, beta, flattening, volume, area = None, None, None, None, None
    
    try:
        if mesh is None or not mesh.is_watertight:
            return None, None, None, None, None
            
        volume = mesh.volume
        area = mesh.area
        
        if volume is None or volume <= 0 or area is None or area <= 0:
            return None, None, None, volume, area

        # 3.1 Flattening calculation (W_mbb / T_mbb)
        obbox = mesh.bounding_box_oriented
        # L_mbb (Length) > W_mbb (Width) > T_mbb (Thickness)
        extents = np.sort(obbox.extents)[::-1] 
        L_mbb, W_mbb, T_mbb = extents
        flattening = W_mbb / T_mbb if T_mbb > 0 else 0

        # 3.2 Chord analysis for Alpha and Beta 
        unique_vertices = np.unique(mesh.vertices, axis=0)
    
        if len(unique_vertices) > MAX_VERTICES_FOR_CHORD_CALC:
            # Randomly sample vertices for faster chord calculation
            indices = random.sample(range(len(unique_vertices)), MAX_VERTICES_FOR_CHORD_CALC)
            unique_vertices = unique_vertices[indices]
            
        if len(unique_vertices) < 4: 
            return None, None, flattening, volume, area

        # Calculation of all chords
        # NOTE: This uses nested loops (O(N^2)) which is a bottleneck but controlled by MAX_VERTICES_FOR_CHORD_CALC
        chords_all = []
        for i in range(len(unique_vertices)):
            for j in range(i + 1, len(unique_vertices)):
                chord_vector = unique_vertices[j] - unique_vertices[i]
                chords_all.append(chord_vector)
        
        chords_all = np.array(chords_all)
        chord_lengths_all = np.linalg.norm(chords_all, axis=1)

        # 3.3 Alpha calculation
        l_avg = np.mean(chord_lengths_all)
        alpha = (area * l_avg) / (7.7 * volume)

        # 3.4 Beta calculation (based on co-orientation of longer chords)
        median_length = np.median(chord_lengths_all)
        valid_chords_mask = chord_lengths_all >= median_length
        chords_filtered = chords_all[valid_chords_mask]
        
        if len(chords_filtered) == 0:
            beta = None
        else:
            # Calculation based on the normalized dot product of the filtered chords
            dot_products_matrix = np.dot(chords_filtered, chords_filtered.T)
            norms_squared_matrix = np.outer(
                np.linalg.norm(chords_filtered, axis=1)**2,
                np.linalg.norm(chords_filtered, axis=1)**2
            )
            
            # Set diagonal elements to zero to avoid self-comparison
            np.fill_diagonal(dot_products_matrix, 0)
            np.fill_diagonal(norms_squared_matrix, 0)
            
            # Avoid division by zero if all products/norms are zero
            denominator = np.sum(norms_squared_matrix)
            if denominator == 0:
                beta = None
            else:
                numerator = np.sum(dot_products_matrix**2)
                # Formula: Beta = 10 * (Sum(dot_products^2) / Sum(norms_squared)) ^ 2
                beta = 10 * (numerator / denominator)**2
                
        # Cast to float, as Trimesh/Numpy might use other numeric types
        return float(alpha), float(beta), float(flattening), float(volume), float(area)
            
    except Exception as e:
        print(f"Error in calculating morphometric indices: {e}")
        return None, None, None, None, None
